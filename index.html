<!doctype html>

<!--

  Created by Huaze
  Version: Beta 1.6.3
  For more info, see: https://github.com/Huaze2/Games

-->

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Games</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --muted: #94a3b8;
      --magenta: #ff00d0;
    }

    body {
      background-color: #121420;
      color: #f1f5f9;
    }
    .collapse-content { height: 0; overflow: hidden; transition: height 240ms ease; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace; }

    .text-btn {
      color: rgb(148 163 184);
      font-size: 0.875rem;
      transition: color 0.15s ease, opacity 0.15s ease;
    }
    .text-btn:hover {
      color: rgb(203 213 225);
      text-decoration: none;
    }

    #gamesContainer > div:hover {
      background-color: rgba(51, 65, 85, 0.6);
    }

    #embedHtmlBtn {
      width: 100%;
    }

    .add-btn {
      position: relative;
      width: 36px;
      height: 36px;
      border-radius: 9999px;
      background-color: rgba(51, 65, 85, 0.4);
      transition: background-color 0.15s ease;
      flex-shrink: 0;
    }
    .add-btn:hover {
      background-color: rgba(71, 85, 105, 0.8);
    }
    .add-btn span {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -54%);
      font-size: 1.45rem;
      font-family: 'Segoe UI', system-ui, sans-serif;
      line-height: 1;
      color: white;
      user-select: none;
      pointer-events: none;
    }

    .badge { background: rgba(255,255,255,0.03); color:var(--muted); padding: 4px 8px; border-radius:999px; font-size: 12px; display:inline-block; }
    .badge-built { color:#7dd3fc; background: rgba(125,211,252,0.06); }
    .badge-custom { color:var(--magenta); background: rgba(255,0,208,0.06); }

    .game-card { min-height: 80px; }

    .custom-highlight {
      box-shadow: 0 6px 18px rgba(255,0,208,0.06);
    }

    #settingsBtn {
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 60;
      width: 44px;
      height: 44px;
      border-radius: 10px;
      display: grid;
      place-items: center;
      background: rgba(255,255,255,0.03);
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease;
      font-size: 18px;
      user-select: none;
    }
    #settingsBtn:hover { transform: scale(1.05); background: rgba(255,255,255,0.05); }

    .settings-overlay {
      position: fixed;
      inset: 0;
      z-index: 50;
      display: none;
      align-items: center;
      justify-content: center;
      /* reduced blur compared to previous (less intense) */
      backdrop-filter: blur(4px) brightness(0.6);
      background: rgba(0,0,0,0.25);
      transition: opacity 200ms ease;
      opacity: 0;
    }
    .settings-overlay.show {
      display: flex;
      opacity: 1;
    }

    .settings-panel {
      width: 92%;
      max-width: 520px;
      background: #0b1220;
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 10px 40px rgba(2,6,23,0.7);
      transform-origin: center;
      z-index: 70;
      opacity: 0;
      transform: scale(.9);
      transition: transform 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease;
      /* ensure panel is scrollable if content exceeds viewport */
      max-height: calc(100vh - 96px);
      overflow: auto;
    }
    .settings-overlay.show .settings-panel {
      opacity: 1;
      transform: scale(1);
    }

    @keyframes pop {
      0% { transform: scale(.95); opacity: 0; }
      60% { transform: scale(1.03); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    .settings-panel.pop {
      animation: pop 260ms cubic-bezier(.2,.9,.2,1);
    }

    /* updated switch */
    .switch {
      width: 52px;
      height: 30px;
      background: rgba(255,255,255,0.10);
      border-radius: 999px;
      position: relative;
      display: inline-block;
      vertical-align: middle;
      transition: background 180ms cubic-bezier(.2,.9,.2,1), box-shadow 120ms ease;
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.25);
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.02);
    }
    .switch .thumb {
      display: block;
      width: 24px;
      height: 24px;
      background: #ffffff;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 3px;
      transform: translateY(-50%);
      transition: left 180ms cubic-bezier(.2,.9,.2,1), transform 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 8px 18px rgba(2,6,23,0.45);
      border: 1px solid rgba(2,6,23,0.08);
    }
    .switch.on {
      background: linear-gradient(90deg, rgba(34,197,94,0.95), rgba(34,197,94,0.95));
      box-shadow: 0 6px 18px rgba(34,197,94,0.06), inset 0 -1px 0 rgba(0,0,0,0.12);
      border: 1px solid rgba(34,197,94,0.12);
    }
    .switch.on .thumb {
      left: 25px;
      transform: translateY(-50%);
    }
    .switch:focus {
      outline: 3px solid rgba(125,211,252,0.12);
      outline-offset: 2px;
    }

    /* --- custom select (replacement for native <select>) --- */
    .custom-select { position: relative; display: inline-block; min-width: 170px; }
    .custom-select-btn {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 10px;
      padding: 10px 12px;
      color: #e6eef8;
      border: 1.8px solid rgba(125,211,252,0.28);
      font-weight: 700;
      font-size: 0.95rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.45);
      width: 100%;
    }
    .custom-select-btn:after {
      content: "▾";
      opacity: 0.8;
      font-size: 12px;
      margin-left: 8px;
    }

    .custom-select-panel {
      position: absolute;
      left: 0;
      right: 0;
      margin-top: 8px;
      background: #07101b;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 18px 48px rgba(2,6,23,0.6);
      max-height: 0;
      opacity: 0;
      transform: translateY(-6px);
      transition: max-height 260ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease, transform 220ms ease;
      z-index: 80;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .custom-select-panel.open {
      max-height: 240px; /* allow it to expand */
      opacity: 1;
      transform: translateY(0);
    }
    .custom-option {
      padding: 12px 14px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      color: #e6eef8;
    }
    /* lighten border more when an option is hovered or selected */
    .custom-option:hover, .custom-option[aria-selected="true"] {
      background: linear-gradient(90deg, rgba(125,211,252,0.04), rgba(125,211,252,0.02));
      /* add a stronger left accent to emulate a lighter border */
      box-shadow: inset 4px 0 0 rgba(125,211,252,0.18);
    }

    /* Settings overlay leave animation helpers */
    .settings-overlay.hide {
      opacity: 0;
      pointer-events: none;
      transition: opacity 220ms ease;
    }
    .settings-panel.leave {
      transform: scale(.97);
      opacity: 0;
      transition: transform 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease;
    }

    .muted { color: #94a3b8; font-size: 13px; }
    .setting-row { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 0; border-bottom: 1px dashed rgba(255,255,255,0.02); }
    .setting-row:last-child { border-bottom: none; }

    .btn-danger {
      background: rgba(255,0,50,0.12);
      color: #ff6b8a;
      border-radius: 8px;
      padding: 8px 12px;
      border: 1px solid rgba(255,0,50,0.08);
    }

    .last-played { color: #9aa7bb; font-size: 12px; margin-left: 6px; }

    /* --- Toasts (top of site) --- */
    .toast-container {
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 110;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
      pointer-events: auto;
      cursor: default;
      width: calc(100% - 40px);
      max-width: 720px;
    }

    .toast {
      pointer-events: auto;
      min-width: 220px;
      max-width: 720px;
      background: linear-gradient(180deg, rgba(6,8,15,0.98), rgba(8,12,20,0.96));
      color: #e6eef8;
      padding: 12px 14px;
      border-radius: 10px;
      box-shadow: 0 12px 36px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.04);
      display: flex;
      gap: 12px;
      align-items: center;
      transform: translateY(-12px) scale(.995);
      opacity: 0;
      transition: transform 260ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease;
      font-weight: 600;
      font-size: 14px;
      cursor: default;
    }
    .toast.show {
      transform: translateY(0) scale(1);
      opacity: 1;
    }

    .toast .toast-msg { flex: 1; color: #e6eef8; }
    .toast .toast-close {
      background: transparent;
      border: none;
      color: rgba(226,238,248,0.8);
      font-size: 16px;
      cursor: pointer;
      opacity: 0.9;
      padding: 4px;
      border-radius: 6px;
    }
    .toast .toast-close:hover { opacity: 1; background: rgba(255,255,255,0.02); }

    /* Action button inside toast (Undo) */
    .toast .toast-action {
      background: rgba(255,255,255,0.03);
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.04);
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 700;
      cursor: pointer;
      margin-left: 8px;
      white-space: nowrap;
    }
    .toast .toast-action:hover {
      filter: brightness(1.08);
    }

    /* ---------------------------
       Confirmation modal (updated)
       - Use fade in/out for overlay + panel
       - Hover states for buttons (lighter/darker)
       --------------------------- */
    .confirm-overlay {
      position: fixed;
      inset: 0;
      /* Keep overlay in DOM but hidden by opacity/visibility to allow smooth transitions */
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 120;
      background: rgba(2,6,23,0.6);
      backdrop-filter: blur(4px) brightness(0.6);
      opacity: 0;
      visibility: hidden;
      transition: opacity 220ms ease, visibility 220ms ease;
      pointer-events: none;
    }
    /* visible state (fade in) */
    .confirm-overlay.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    /* ensure hide state (for explicit use) */
    .confirm-overlay.hide {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .confirm-panel {
      width: 92%;
      max-width: 520px;
      background: #07101b;
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 12px 48px rgba(2,6,23,0.7);
      transform-origin: center;
      opacity: 0;
      transform: translateY(8px) scale(.98);
      transition: transform 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease;
      border: 1px solid rgba(255,255,255,0.03);
    }
    /* panel visible (combined with overlay.show) */
    .confirm-overlay.show .confirm-panel {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .confirm-title { font-weight: 700; font-size: 1.05rem; color: #e6eef8; }
    .confirm-msg { color: var(--muted); margin-top: 8px; font-size: 0.95rem; white-space: pre-wrap; }
    .confirm-actions { margin-top: 18px; display:flex; justify-content:flex-end; gap:8px; }
    .confirm-btn { padding: 8px 12px; border-radius: 8px; font-weight: 700; cursor: pointer; border: 1px solid rgba(255,255,255,0.03); transition: background 150ms ease, transform 120ms ease, filter 120ms ease; }
    .confirm-cancel { background: rgba(255,255,255,0.02); color: #cbd5e1; }
    .confirm-ok { background: linear-gradient(90deg, rgba(220,38,38,0.95), rgba(239,68,68,0.95)); color: white; border: none; }
    .confirm-ok.neutral { background: linear-gradient(90deg, rgba(34,197,94,0.95), rgba(34,197,94,0.95)); }

    /* Hover states: cancel -> slightly lighter background; OK -> slightly darker background (neutral OK brightens) */
    .confirm-cancel:hover {
      background: rgba(255,255,255,0.04);
      /* intentionally only changing background brightness on hover — no movement */
    }
    .confirm-ok:hover {
      background: linear-gradient(90deg, rgba(200,30,30,0.95), rgba(220,50,50,0.95));
      /* intentionally only changing background darkness on hover — no movement */
    }
    .confirm-ok.neutral:hover {
      background: linear-gradient(90deg, rgba(50,220,110,0.95), rgba(50,220,110,0.95));
      /* neutral (non-destructive) confirm brightens slightly on hover */
    }

    /* Export fallback panel adjustments (kept for potential styling of modals) */
    .export-panel textarea {
      width: 100%;
      min-height: 280px;
      background: #07101b;
      color: #e6eef8;
      border-radius: 8px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.04);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace;
      font-size: 13px;
      resize: vertical;
    }
    .export-actions { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
    .export-actions .btn { padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; border:1px solid rgba(255,255,255,0.03); }
    .export-actions .btn.copy { background: linear-gradient(90deg, rgba(59,130,246,0.95), rgba(37,99,235,0.95)); color:white; }
    .export-actions .btn.open { background: linear-gradient(90deg, rgba(99,102,241,0.95), rgba(79,70,229,0.95)); color:white; }
    .export-actions .btn.close { background: rgba(255,255,255,0.02); color:#cbd5e1; }

    /* Editor textarea style - blends in with theme */
    .editor-textarea {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      border-radius: 8px;
      padding: 12px;
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.03);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace;
      font-size: 13px;
      resize: vertical;
    }
    .editor-textarea:focus {
      outline: 3px solid rgba(125,211,252,0.08);
      outline-offset: 2px;
    }

  </style>
</head>

<body class="min-h-screen text-slate-100">
  <button id="settingsBtn" title="Settings">⚙</button>

  <!-- Toast container (top center) -->
  <div id="toastContainer" class="toast-container" aria-live="polite" aria-atomic="true"></div>

  <!-- Settings overlay -->
  <div id="settingsOverlay" class="settings-overlay" aria-hidden="true">
    <div id="settingsPanel" class="settings-panel" role="dialog" aria-modal="true" aria-label="Settings">
      <div class="flex items-start justify-between mb-3">
        <div>
          <h3 class="text-lg font-semibold">Settings</h3>
          <div class="muted text-sm">Customize how games are displayed and managed</div>
        </div>
        <button id="closeSettings" class="text-btn" title="Close">✕</button>
      </div>

      <div class="mt-2">
        <div class="setting-row">
          <div>
            <div class="font-medium">Highlight magenta border to custom games</div>
          </div>
          <div>
            <button id="toggleHighlight" class="switch" role="switch" aria-checked="true" aria-label="Highlight custom games">
              <span class="thumb" aria-hidden="true"></span>
            </button>
          </div>
        </div>

        <div class="setting-row">
          <div>
            <div class="font-medium">Show last played</div>
          </div>
          <div>
            <button id="toggleLastPlayed" class="switch" role="switch" aria-checked="true" aria-label="Show last played">
              <span class="thumb" aria-hidden="true"></span>
            </button>
          </div>
        </div>

        <!-- Show main menu (above sort) -->
        <div class="setting-row">
          <div>
            <div class="font-medium">Show main menu</div>
          </div>
          <div>
            <button id="toggleMainMenu" class="switch" role="switch" aria-checked="true" aria-label="Show main menu">
              <span class="thumb" aria-hidden="true"></span>
            </button>
          </div>
        </div>

        <div class="setting-row">
          <div>
            <div class="font-medium">Sort games</div>
          </div>
          <div>
            <!-- custom dropdown control (replaces native select so we can animate the options) -->
            <div class="custom-select" id="sortSelect">
              <button id="sortSelectBtn" class="custom-select-btn" aria-haspopup="listbox" aria-expanded="false">Alphabetically</button>
              <div id="sortOptions" class="custom-select-panel" role="listbox" tabindex="-1" aria-hidden="true">
                <div role="option" data-value="alpha" class="custom-option" aria-selected="true">Alphabetically</div>
                <div role="option" data-value="recent" class="custom-option" aria-selected="false">Recently played</div>
              </div>
            </div>
          </div>
        </div>

        <!-- New: Show filter dropdown (mirrors sort dropdown style) -->
        <div class="setting-row">
          <div>
            <div class="font-medium">Filter games</div>
          </div>
          <div>
            <div class="custom-select" id="showFilterSelect">
              <button id="showFilterSelectBtn" class="custom-select-btn" aria-haspopup="listbox" aria-expanded="false">All games</button>
              <div id="showFilterOptions" class="custom-select-panel" role="listbox" tabindex="-1" aria-hidden="true">
                <div role="option" data-value="all" class="custom-option" aria-selected="true">All games</div>
                <div role="option" data-value="built" class="custom-option" aria-selected="false">Built-in only</div>
                <div role="option" data-value="custom" class="custom-option" aria-selected="false">Custom only</div>
              </div>
            </div>
          </div>
        </div>

        <div class="setting-row">
          <div>
            <div class="font-medium">Delete all custom games</div>
          </div>
          <div>
            <button id="deleteAllCustom" class="btn-danger">Delete</button>
          </div>
        </div>

        <div class="setting-row">
          <div>
            <div class="font-medium">Delete all local storage</div>
            <div class="muted">Clears all local data</div>
          </div>
          <div>
            <button id="deleteAllLocalStorage" class="btn-danger">Clear All</button>
          </div>
        </div>

        <!-- New Import / Export row -->
        <div class="setting-row">
          <div>
            <div class="font-medium">Import / Export</div>
            <div class="muted">Import / Export data from a JSON file</div>
          </div>
          <div class="flex gap-3 items-center">
            <!-- Slightly bigger / improved look for these buttons -->
            <button id="importStorageBtn" class="px-4 py-2 rounded-lg bg-slate-700/30 border border-slate-600 text-sm font-semibold hover:bg-slate-700/40">Import</button>
            <button id="exportStorageBtn" class="px-4 py-2 rounded-lg bg-indigo-600 text-sm font-semibold hover:bg-indigo-500">Export</button>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Confirmation modal (reusable) -->
  <div id="confirmOverlay" class="confirm-overlay" aria-hidden="true">
    <div id="confirmPanel" class="confirm-panel" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmMsg">
      <div>
        <div id="confirmTitle" class="confirm-title">Confirm</div>
        <div id="confirmMsg" class="confirm-msg">Are you sure?</div>
        <div class="confirm-actions">
          <button id="confirmCancelBtn" class="confirm-btn confirm-cancel">Cancel</button>
          <button id="confirmOkBtn" class="confirm-btn confirm-ok">Delete</button>
        </div>
      </div>
    </div>
  </div>

  <div class="max-w-3xl mx-auto p-6">
    <!-- MAIN VIEW -->
    <div id="mainView" class="bg-slate-800/70 backdrop-blur rounded-2xl p-6 shadow-xl">
      <h1 class="text-xl font-semibold mb-2">Open Website</h1>
      <p class="text-sm text-slate-400 mb-4">Embed a link or raw HTML into a new <code class="bg-slate-700 px-1 rounded">about:blank</code> window.</p>

      <div class="space-y-3">
        <div class="flex gap-3">
          <input id="link" type="text" placeholder="Type URL here" class="flex-1 bg-slate-700/40 placeholder:text-slate-400 text-slate-100 px-3 py-2 rounded-md focus:outline-none" />
          <button id="embedBtn" class="px-4 py-2 rounded-md bg-indigo-600 hover:bg-indigo-700">Embed Link</button>
        </div>

        <div>
          <textarea id="htmlCode" rows="5" placeholder="Type HTML code here" class="w-full bg-slate-700/40 placeholder:text-slate-400 text-slate-100 px-3 py-2 rounded-md focus:outline-none mono"></textarea>
          <div class="flex justify-end mt-2">
            <button id="embedHtmlBtn" class="px-4 py-2 rounded-md bg-emerald-600 hover:bg-emerald-700">Embed HTML</button>
          </div>
        </div>

        <p class="text-xs text-slate-400">Some websites prevent embedding via security headers (X-Frame-Options or CSP).</p>

        <div class="pt-3 border-t border-slate-700 mt-3 text-right">
          <button id="gamesLink" class="text-btn">Games →</button>
        </div>
      </div>
    </div>

    <!-- GAMES VIEW -->
    <div id="gamesView" class="hidden bg-slate-800/70 backdrop-blur rounded-2xl p-6 shadow-xl mt-6 relative">
      <div class="flex items-center justify-between mb-4">
        <div>
          <h2 class="text-lg font-semibold">Games</h2>
          <p class="text-sm text-slate-400">This project is still in <i>beta</i>, no games are added yet, these are just placeholders.</p>
        </div>
        <button id="backBtn" class="px-3 py-2 rounded-md bg-slate-700/40 hover:bg-slate-600">Back</button>
      </div>

      <!-- Search + Add Button Row -->
      <div class="flex gap-2 mb-4 items-center">
        <input id="searchInput" type="text" placeholder="Search games" class="flex-1 bg-slate-700/40 placeholder:text-slate-400 text-slate-100 px-3 py-2 rounded-md focus:outline-none" />

        <!-- Centered add button -->
        <button id="addGameBtn" class="add-btn" aria-label="Add new game">
          <span>+</span>
        </button>
      </div>

      <div id="gamesContainer" class="space-y-3"></div>
    </div>

    <!-- ADD GAME VIEW -->
    <div id="addGameView" class="hidden bg-slate-800/70 backdrop-blur rounded-2xl p-6 shadow-xl mt-6">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-lg font-semibold">Add Game</h2>
        <button id="cancelAddBtn" class="px-3 py-2 rounded-md bg-slate-700/40 hover:bg-slate-600">Cancel</button>
      </div>

      <div class="space-y-3">
        <input id="newGameTitle" type="text" placeholder="Title" class="w-full bg-slate-700/40 text-slate-100 placeholder:text-slate-400 px-3 py-2 rounded-md focus:outline-none" />
        <textarea id="newGameCode" rows="8" placeholder="Code" class="w-full bg-slate-700/40 text-slate-100 placeholder:text-slate-400 px-3 py-2 mono focus:outline-none rounded-md"></textarea>
        <button id="confirmAddBtn" class="w-full px-4 py-2 rounded-md bg-emerald-600 hover:bg-emerald-700">Add</button>
      </div>
    </div>
  </div>

  <!-- Hidden file input for import -->
  <input id="importFileInput" type="file" accept="application/json" style="display:none" />

  <script>
    // Keys
    const LOCAL_KEY = 'embed_playground_custom_games_v1';
    const SETTINGS_KEY = 'embed_playground_settings_v1';
    const LAST_PLAYED_KEY = 'embed_playground_last_played_v1';

    // --- Toast helper (replaces alert usage) ---
    const toastContainer = document.getElementById('toastContainer');
    /**
     * showToast - shows a toast message
     * - default duration is 2000ms (2 seconds)
     * - enforces a maximum of 2 toasts at a time: removes oldest immediately when exceeding
     * - supports an optional action: { label: 'Undo', onClick: () => { ... } }
     */
    function showToast(message, opts = {}) {
      const { type = 'info', duration = 2000, action = null } = opts;

      const id = `toast_${Date.now()}_${Math.floor(Math.random()*1000)}`;
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.id = id;

      // Build inner content
      const msgDiv = document.createElement('div');
      msgDiv.className = 'toast-msg';
      msgDiv.textContent = message;

      toast.appendChild(msgDiv);

      // If an action object is provided, add an action button (e.g., Undo)
      if(action && action.label && typeof action.onClick === 'function'){
        const actionBtn = document.createElement('button');
        actionBtn.className = 'toast-action';
        actionBtn.type = 'button';
        actionBtn.textContent = action.label;
        actionBtn.title = action.label;
        actionBtn.addEventListener('click', (ev) => {
          try {
            action.onClick();
          } catch (err) {
            console.warn('Toast action failed', err);
          }
          // remove toast once action executed
          animatedRemove();
        });
        toast.appendChild(actionBtn);
      }

      // close button
      const closeBtn = document.createElement('button');
      closeBtn.className = 'toast-close';
      closeBtn.setAttribute('aria-label','Close notification');
      closeBtn.innerHTML = '&times;';
      closeBtn.addEventListener('click', () => {
        animatedRemove();
      });
      toast.appendChild(closeBtn);

      // Helper: animated removal (used on normal dismiss/close)
      function animatedRemove() {
        try { clearTimeout(toast._toastTimeout); } catch (e) {}
        toast.classList.remove('show');
        setTimeout(() => { try { toast.remove(); } catch (e) {} }, 280);
      }

      // Helper: immediate removal (used when trimming extra toasts)
      function immediateRemove() {
        try { clearTimeout(toast._toastTimeout); } catch (e) {}
        try { toast.remove(); } catch (e) {}
      }

      // attach helpers to element so trimming logic can access them
      toast._toastRemove = animatedRemove;
      toast._toastRemoveImmediate = immediateRemove;

      // append then animate in
      toastContainer.appendChild(toast);
      // ensure CSS transition runs
      requestAnimationFrame(() => toast.classList.add('show'));

      // auto-dismiss with animation
      const timeout = setTimeout(() => {
        animatedRemove();
      }, duration);
      toast._toastTimeout = timeout;

      // After appending, ensure we do not exceed max visible toasts.
      // If there are more than 2, remove the oldest(s) immediately (no animation) so nothing interactive gets stuck.
      while (toastContainer.children.length > 2) {
        const oldest = toastContainer.children[0];
        if (!oldest) break;
        // If oldest has immediate removal helper, use it; otherwise remove element directly
        if (typeof oldest._toastRemoveImmediate === 'function') {
          oldest._toastRemoveImmediate();
        } else {
          try { // best-effort immediate cleanup
            if (oldest._toastTimeout) try { clearTimeout(oldest._toastTimeout); } catch(e){}
            oldest.remove();
          } catch (e) {}
        }
      }

      return { id, remove: animatedRemove };
    }

    // Built-in games (cannot be deleted)
    const builtInGames = [
      {
        name: 'Basic HTML Page',
        code: `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body style="font-family:system-ui,Segoe UI,Roboto,Arial;margin:32px;color:#111">
  <h1>Hello, world!</h1>
</body>
</html>`,
        built: true
      },
      {
        name: 'Clock',
        code: `<div style="font-family:system-ui,Segoe UI,Roboto,Arial;text-align:center;margin:40px;color:#111">
  <h2>Digital Clock</h2>
  <div id="clock" style="font-size:32px;margin-top:12px"></div>
</div>
<script>
  const el = document.getElementById('clock');
  function tick(){ if(el) el.textContent = new Date().toLocaleTimeString(); }
  tick(); setInterval(tick,1000);
<\/script>`,
        built: true
      },
      {
        name: 'Simple Counter',
        code: `<div style="font-family:system-ui,Segoe UI,Roboto,Arial;text-align:center;margin:40px;color:#111">
  <h2>Counter</h2>
  <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
    <button id="dec">-</button>
    <div id="val">0</div>
    <button id="inc">+</button>
  </div>
</div>
<script>
  const v = document.getElementById('val');
  let n = 0; document.getElementById('inc').addEventListener('click',()=>{ n++; v.textContent = n });
  document.getElementById('dec').addEventListener('click',()=>{ n--; v.textContent = n });
<\/script>`,
        built: true
      }
    ];

    // load/save custom games
    function loadCustomGames(){
      try{
        const raw = localStorage.getItem(LOCAL_KEY);
        if(!raw) return [];
        const parsed = JSON.parse(raw);
        if(!Array.isArray(parsed)) return [];
        return parsed.map(p => ({ name: String(p.name || ''), code: String(p.code || ''), built: false }));
      }catch(e){
        console.warn('Failed to load custom games', e);
        return [];
      }
    }
    function saveCustomGames(){
      try{
        const toSave = customGames.map(g => ({ name: g.name, code: g.code }));
        localStorage.setItem(LOCAL_KEY, JSON.stringify(toSave));
      }catch(e){ console.warn('Failed to save custom games', e); }
    }

    // settings
    const defaultSettings = {
      highlightCustom: true,
      showLastPlayed: true,
      sort: 'alpha', // 'alpha' or 'recent'
      showMainMenu: true, // whether the main landing page is visible by default
      showFilter: 'all' // 'all' | 'built' | 'custom'  (new)
    };
    function loadSettings(){
      try{
        const raw = localStorage.getItem(SETTINGS_KEY);
        if(!raw) return { ...defaultSettings };
        const parsed = JSON.parse(raw);
        return Object.assign({}, defaultSettings, parsed);
      }catch(e){
        return { ...defaultSettings };
      }
    }
    function saveSettings(){
      try{
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      }catch(e){ console.warn('Failed to save settings', e); }
    }

    // lastPlayed map: { "<gameName>": timestamp }
    function loadLastPlayed(){
      try{
        const raw = localStorage.getItem(LAST_PLAYED_KEY);
        if(!raw) return {};
        return JSON.parse(raw);
      }catch(e){ return {}; }
    }
    function saveLastPlayed(){
      try{ localStorage.setItem(LAST_PLAYED_KEY, JSON.stringify(lastPlayed)); }catch(e){ console.warn('Failed to save lastPlayed', e); }
    }

    let customGames = loadCustomGames();
    let settings = loadSettings();
    let lastPlayed = loadLastPlayed();

    function allGames(){
      return builtInGames.concat(customGames);
    }

    // DOM refs
    const mainView = document.getElementById('mainView');
    const gamesView = document.getElementById('gamesView');
    const addGameView = document.getElementById('addGameView');
    const gamesContainer = document.getElementById('gamesContainer');
    const searchInput = document.getElementById('searchInput');
    const addGameBtn = document.getElementById('addGameBtn');
    const confirmAddBtn = document.getElementById('confirmAddBtn');
    const cancelAddBtn = document.getElementById('cancelAddBtn');
    const newGameTitle = document.getElementById('newGameTitle');
    const newGameCode = document.getElementById('newGameCode');

    // settings elements
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsOverlay = document.getElementById('settingsOverlay');
    const settingsPanel = document.getElementById('settingsPanel');
    const closeSettings = document.getElementById('closeSettings');
   
    const toggleHighlight = document.getElementById('toggleHighlight');
    const toggleLastPlayed = document.getElementById('toggleLastPlayed');
    const deleteAllCustom = document.getElementById('deleteAllCustom');
    const deleteAllLocalStorage = document.getElementById('deleteAllLocalStorage');
    const toggleMainMenu = document.getElementById('toggleMainMenu');
    const backBtn = document.getElementById('backBtn');

    const importStorageBtn = document.getElementById('importStorageBtn');
    const exportStorageBtn = document.getElementById('exportStorageBtn');
    const importFileInput = document.getElementById('importFileInput');

    // custom-select refs
    const sortSelectBtn = document.getElementById('sortSelectBtn');
    const sortOptions = document.getElementById('sortOptions');

    // show filter select refs (new)
    const showFilterSelectBtn = document.getElementById('showFilterSelectBtn');
    const showFilterOptions = document.getElementById('showFilterOptions');

    // confirmation modal refs (new)
    const confirmOverlay = document.getElementById('confirmOverlay');
    const confirmPanel = document.getElementById('confirmPanel');
    const confirmTitle = document.getElementById('confirmTitle');
    const confirmMsg = document.getElementById('confirmMsg');
    const confirmCancelBtn = document.getElementById('confirmCancelBtn');
    const confirmOkBtn = document.getElementById('confirmOkBtn');

    // wire up page navigation
    document.getElementById('gamesLink').addEventListener('click', showGames);
    backBtn.addEventListener('click', showMain);
    addGameBtn.addEventListener('click', showAddGame);
    cancelAddBtn.addEventListener('click', showGames);
    confirmAddBtn.addEventListener('click', addNewGame);

    function showGames(){
      mainView.classList.add('hidden');
      addGameView.classList.add('hidden');
      gamesView.classList.remove('hidden');
      renderGames();
      window.scrollTo(0,0);
    }
    function showMain(){
      // only show main view if setting allows it
      if(!settings.showMainMenu) {
        // If main menu is disabled, bring user to games view
        showGames();
        return;
      }
      gamesView.classList.add('hidden');
      addGameView.classList.add('hidden');
      mainView.classList.remove('hidden');
      window.scrollTo(0,0);
    }
    function showAddGame(){
      gamesView.classList.add('hidden');
      mainView.classList.add('hidden');
      addGameView.classList.remove('hidden');
      newGameTitle.value = '';
      newGameCode.value = '';
    }

    function addNewGame(){
      const name = newGameTitle.value.trim();
      const code = newGameCode.value.trim();
      if(!name || !code){
        showToast('Please enter both a title and game code.', { type: 'warn' });
        return;
      }
      customGames.push({ name, code, built: false });
      saveCustomGames();
      showGames();
      showToast(`Added "${name}".`, { type: 'success' });
    }

    // ------------------------
    // Real-time relative last-played helpers
    // ------------------------
    function formatRelative(ts, now = Date.now()){
      if(!ts) return 'Never played';
      const s = Math.max(0, Math.floor((now - ts) / 1000));
      if(s < 5) return 'Last played: just now';
      if(s < 60) return `Last played: ${s}s ago`;
      const m = Math.floor(s / 60);
      if(m < 60) return `Last played: ${m}m ago`;
      const h = Math.floor(m / 60);
      if(h < 24) return `Last played: ${h}h ago`;
      const d = Math.floor(h / 24);
      return `Last played: ${d}d ago`;
    }

    // Update every second so relative times stay current
    function updateRelativeTimestamps(){
      const els = document.querySelectorAll('[data-last-ts]');
      const now = Date.now();
      els.forEach(el => {
        const ts = Number(el.getAttribute('data-last-ts')) || 0;
        if(!ts) {
          el.textContent = 'Never played';
        } else {
          el.textContent = formatRelative(ts, now);
        }
      });
    }
    setInterval(updateRelativeTimestamps, 1000);

    // render with settings applied
    function renderGames(filterText = ''){
      const f = (filterText || '').toLowerCase();

      // combine
      let combined = allGames().slice();

      // apply show filter (new)
      if(settings.showFilter === 'built'){
        combined = combined.filter(g => Boolean(g.built));
      } else if(settings.showFilter === 'custom'){
        combined = combined.filter(g => !g.built);
      }

      // attach lastPlayed timestamp proxy (0 if none)
      combined.forEach(g => {
        const key = keyForLastPlayed(g);
        g.__last = lastPlayed[key] || 0;
      });

      // sort based on settings
      if(settings.sort === 'recent'){
        combined.sort((a,b) => (b.__last || 0) - (a.__last || 0) || a.name.localeCompare(b.name));
      } else {
        combined.sort((a,b) => a.name.localeCompare(b.name));
      }

      const filtered = combined.filter(g => g.name.toLowerCase().includes(f));

      gamesContainer.innerHTML = '';
      filtered.forEach(g => {
        const card = document.createElement('div');
        card.className = 'bg-slate-700/40 p-3 rounded-lg border border-slate-700 cursor-pointer transition-colors duration-150 flex flex-col justify-between game-card';

        // highlight custom if enabled (inline style to force border color)
        if(!g.built && settings.highlightCustom){
          card.classList.add('custom-highlight');
          card.style.border = `1px solid var(--magenta)`;
          card.style.boxShadow = '0 8px 28px rgba(255,0,208,0.06)';
        } else {
          card.style.border = '';
          card.style.boxShadow = '';
        }

        const header = document.createElement('div');
        header.className = 'w-full flex items-start justify-between gap-3';

        const titleWrap = document.createElement('div');
        titleWrap.className = 'flex-1';

        // Title + badge under it
        const title = document.createElement('div');
        title.innerHTML = `<span class="font-medium">${escapeHtml(g.name)}</span>`;

        const badgeRow = document.createElement('div');
    
        badgeRow.className = 'mt-2 flex items-center gap-3';

        const isBuilt = Boolean(g.built);
     
        const badgeSpan = document.createElement('span');
        badgeSpan.className = 'badge ' + (isBuilt ? 'badge-built' : 'badge-custom');
        badgeSpan.innerText = isBuilt ? 'built-in' : 'custom';
        badgeRow.appendChild(badgeSpan);

        // optionally show last played small text (relative, live-updating)
        if(settings.showLastPlayed){
          const lpKey = keyForLastPlayed(g);
          const ts = lastPlayed[lpKey] || 0;
          const lpDiv = document.createElement('div');
          lpDiv.className = 'last-played';
          lpDiv.setAttribute('data-last-ts', ts);
          lpDiv.textContent = ts ? formatRelative(ts) : 'Never played';
          badgeRow.appendChild(lpDiv);
        }

        titleWrap.appendChild(title);
        titleWrap.appendChild(badgeRow);

        const actions = document.createElement('div');
        actions.className = 'flex gap-3 items-center ml-3';

        const copyBtn = document.createElement('button');
        copyBtn.className = 'text-btn';
        copyBtn.textContent = 'Copy';
        copyBtn.title = 'Copy code';
        copyBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          try {
            await navigator.clipboard.writeText(g.code);
          } catch {
            const temp = document.createElement('textarea');
            temp.value = g.code;
            document.body.appendChild(temp);
            temp.select();
            try { document.execCommand('copy'); } catch(e){}
            document.body.removeChild(temp);
          }
          const old = copyBtn.textContent;
          copyBtn.textContent = 'Copied!';
          setTimeout(()=> copyBtn.textContent = old, 1200);
          showToast('Code copied to clipboard.', { type: 'success' });
        });

        const openBtn = document.createElement('button');
        openBtn.className = 'text-btn';
        openBtn.textContent = 'Open';
        openBtn.title = 'Open in new window';
        openBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const newWin = window.open('about:blank', '_blank');
         
          if(!newWin){ showToast('Unable to open new window. Popup blocked?', { type: 'error' }); return; }
          newWin.document.open();
          newWin.document.write(g.code);
          newWin.document.close();
          // record last played
          const key = keyForLastPlayed(g);
          lastPlayed[key] = Date.now();
          saveLastPlayed();
          // update any visible last-played elements immediately
          const elements = document.querySelectorAll(`[data-last-ts]`);
          elements.forEach(el => {
            const name = getNameFromCardElement(el);
            if(name === g.name){
              el.setAttribute('data-last-ts', lastPlayed[key]);
              el.textContent = formatRelative(lastPlayed[key]);
            }
          });
          // if current sort is 'recent' re-render to update order
          if(settings.sort === 'recent') renderGames(searchInput.value);
          // NOTE: per request, do not show a toast when opening a game.
        });

        // Delete button (❌)
        const delBtn = document.createElement('button');
        delBtn.className = 'text-btn';
        delBtn.textContent = '❌';
        delBtn.title = 'Delete game';
        delBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          handleDeleteGame(g); // now async internally
        });

        actions.appendChild(copyBtn);
        actions.appendChild(openBtn);
        actions.appendChild(delBtn);

        header.appendChild(titleWrap);
        header.appendChild(actions);
        card.appendChild(header);

        const contentWrap = document.createElement('div');
        contentWrap.className = 'collapse-content mt-3';

        const pre = document.createElement('pre');
        pre.className = 'bg-slate-800 p-3 rounded-md text-sm overflow-auto mono';
        pre.style.maxHeight = '320px';
        pre.textContent = g.code;

        contentWrap.appendChild(pre);

        // Edit controls (only for custom games)
        if(!g.built){
          const editControlsWrap = document.createElement('div');
          editControlsWrap.className = 'mt-3 flex justify-end gap-2';
          // helper to create the single "Edit" button
          const createEditButton = () => {
            const editBtn = document.createElement('button');
            editBtn.className = 'px-3 py-1 rounded-md bg-slate-700/40 text-sm text-btn';
            editBtn.textContent = 'Edit';
            editBtn.title = 'Edit code';
            editBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              startEditing();
            });
            return editBtn;
          };

          let currentEditBtn = createEditButton();
          editControlsWrap.appendChild(currentEditBtn);
          contentWrap.appendChild(editControlsWrap);

          // Editing state
          let editing = false;
          let textarea = null;
          let cancelBtn = null;
          let submitBtn = null;

          function startEditing(){
            if(editing) return;
            editing = true;
            // stop card toggling while interacting with form elements by stopping propagation
            // replace pre with textarea
            textarea = document.createElement('textarea');
            // Use editor-textarea to blend with theme
            textarea.className = 'w-full editor-textarea rounded-md text-sm mono';
            textarea.style.minHeight = '180px';
            textarea.value = g.code;
            // ensure click on textarea doesn't collapse card
            textarea.addEventListener('click', (ev) => ev.stopPropagation());
            textarea.addEventListener('keydown', (ev) => ev.stopPropagation());

            contentWrap.replaceChild(textarea, pre);

            // replace edit button with Cancel + Submit
            editControlsWrap.removeChild(currentEditBtn);

            cancelBtn = document.createElement('button');
            cancelBtn.className = 'px-3 py-1 rounded-md bg-slate-700/40 text-sm';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              stopEditing(false);
            });

            submitBtn = document.createElement('button');
            submitBtn.className = 'px-3 py-1 rounded-md bg-emerald-600 hover:bg-emerald-700 text-sm';
            submitBtn.textContent = 'Submit';
            submitBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              stopEditing(true);
            });

            editControlsWrap.appendChild(cancelBtn);
            editControlsWrap.appendChild(submitBtn);

            // focus textarea
            setTimeout(() => textarea.focus(), 40);
          }

          function stopEditing(submit){
            if(!editing) return;
            // if submit, validate and update the game's code
            if(submit){
              const newCode = String((textarea && textarea.value) || '');
              if(!newCode.trim()){
                // Do not exit editing; show error and keep textarea visible
                showToast('Cannot save empty code. Please enter some code.', { type: 'error' });
                if(textarea) textarea.focus();
                return;
              }
              // proceed with saving
              editing = false;
              // Update the customGames array (find by name)
              const idx = customGames.findIndex(c => c.name === g.name);
              if(idx !== -1){
                customGames[idx].code = newCode;
                // Also update the 'g' reference used in this render, for consistency:
                g.code = newCode;
                saveCustomGames();
                pre.textContent = newCode;
                showToast(`Saved "${g.name}".`, { type: 'success' });
              } else {
                // As fallback, update g directly and persist (best effort)
                g.code = newCode;
                saveCustomGames();
                pre.textContent = newCode;
                showToast(`Saved "${g.name}".`, { type: 'success' });
              }
            } else {
              // Cancel case: just exit editing without saving
              editing = false;
            }

            // restore pre if editing was ended (either saved or cancelled)
            if(!editing){
              contentWrap.replaceChild(pre, textarea);
              textarea = null;

              // remove cancel/submit buttons and restore edit button
              if(cancelBtn) { cancelBtn.remove(); cancelBtn = null; }
              if(submitBtn) { submitBtn.remove(); submitBtn = null; }

              currentEditBtn = createEditButton();
              editControlsWrap.appendChild(currentEditBtn);
            }
          }
        }

        card.appendChild(contentWrap);

        // attach data-name on a small hidden attribute to help locating which last-played belongs to which game
        card.setAttribute('data-game-name', g.name);

        let expanded = false;
        card.addEventListener('click', () => {
          expanded = !expanded;
          toggleCollapse(contentWrap, expanded);
        });

        gamesContainer.appendChild(card);
      });

      if(filtered.length === 0){
        const note = document.createElement('div');
        note.className = 'text-sm text-slate-400 p-3';
        note.textContent = 'No games found.';
        gamesContainer.appendChild(note);
      }

      // ensure relative times are fresh immediately after rendering
      updateRelativeTimestamps();
    }

    // Helper to match last-played elements to cards:
    function getNameFromCardElement(el){
      let node = el;
      while(node && node !== document.body){
        if(node.hasAttribute && node.hasAttribute('data-game-name')) return node.getAttribute('data-game-name');
        node = node.parentNode;
      }
      return null;
    }

    function keyForLastPlayed(g){
      return String(g.name);
    }

    searchInput.addEventListener('input', e => renderGames(e.target.value));

    function toggleCollapse(el, open){
      if(open){
        el.style.display = 'block';
        const h = el.scrollHeight + 'px';
        el.style.height = '0px';
        requestAnimationFrame(()=>{ el.style.height = h; });
        setTimeout(()=>{ el.style.height = 'auto'; }, 260);
      } else {
        const h = el.scrollHeight + 'px';
        el.style.height = h;
        requestAnimationFrame(()=>{ el.style.height = '0px'; });
        setTimeout(()=>{ el.style.display = 'none'; }, 260);
      }
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[ch])); }

    // --------------------------
    // Reusable confirmation modal
    // returns Promise<boolean>
    // --------------------------
    let _confirmResolve = null;
    let _confirmActive = false;
    function confirmDialog(message, opts = {}) {
      // opts: { title, confirmText, cancelText, destructive }
      if(_confirmActive) {
        // if another confirmation is shown, resolve false to avoid stacking
        return Promise.resolve(false);
      }
      _confirmActive = true;
      confirmTitle.textContent = opts.title || 'Confirm';
      confirmMsg.textContent = message || 'Are you sure?';
      confirmOkBtn.textContent = opts.confirmText || (opts.destructive ? 'Delete' : 'OK');
      confirmCancelBtn.textContent = opts.cancelText || 'Cancel';

      // style confirm button if neutral vs destructive
      confirmOkBtn.classList.remove('neutral');
      if(!opts.destructive) {
        confirmOkBtn.classList.add('neutral');
      }

      // Show overlay using CSS-driven fade-in
      confirmOverlay.classList.remove('hide');
      // Force a frame so transition reliably runs
      requestAnimationFrame(() => {
        confirmOverlay.classList.add('show');
        confirmOverlay.setAttribute('aria-hidden', 'false');
      });

      // focus management
      setTimeout(() => confirmOkBtn.focus(), 160);

      return new Promise((resolve) => {
        _confirmResolve = (val) => {
          // start fade-out by removing show and adding hide
          confirmOverlay.classList.remove('show');
          confirmOverlay.setAttribute('aria-hidden', 'true');
          confirmOverlay.classList.add('hide');

          // Resolve after transition finishes (listen for overlay opacity transition)
          const onTransitionEnd = (ev) => {
            if(ev && ev.target !== confirmOverlay) return;
            confirmOverlay.removeEventListener('transitionend', onTransitionEnd);
            _confirmActive = false;
            resolve(val);
            _confirmResolve = null;
          };

          confirmOverlay.addEventListener('transitionend', onTransitionEnd, { once: true });

          // Fallback: safety timeout in case transitionend didn't fire
          setTimeout(() => {
            if(_confirmResolve) {
              confirmOverlay.removeEventListener('transitionend', onTransitionEnd);
              _confirmActive = false;
              resolve(val);
              _confirmResolve = null;
            }
          }, 360);
        };

        // click handlers are attached below (they call _confirmResolve)
      });
    }

    // Hook up overlay controls (single shared handlers)
    confirmCancelBtn.addEventListener('click', () => {
      if(typeof _confirmResolve === 'function') _confirmResolve(false);
    });
    confirmOkBtn.addEventListener('click', () => {
      if(typeof _confirmResolve === 'function') _confirmResolve(true);
    });

    // Allow clicking backdrop to cancel
    confirmOverlay.addEventListener('click', (e) => {
      if(e.target === confirmOverlay) {
        if(typeof _confirmResolve === 'function') _confirmResolve(false);
      }
    });

    // keyboard handling while modal open
    document.addEventListener('keydown', (e) => {
      if(!_confirmActive) return;
      if(e.key === 'Escape') {
        if(typeof _confirmResolve === 'function') _confirmResolve(false);
      } else if(e.key === 'Enter') {
        if(typeof _confirmResolve === 'function') _confirmResolve(true);
      }
    });

    // --------------------------
    // Delete logic (now uses modal)
    // --------------------------
    async function handleDeleteGame(game){
      if(game.built){
        showToast('This game is built-in and cannot be deleted.', { type: 'warn' });
        return;
      }
      const ok = await confirmDialog(`Delete "${game.name}"? This action cannot be undone.`, { title: 'Delete Game', confirmText: 'Delete', cancelText: 'Cancel', destructive: true });
      if(!ok) return;

      // Determine index to remove (prefer exact match of name+code)
      let idx = customGames.findIndex(c => c.name === game.name && c.code === game.code);
      if(idx === -1){
        const idx2 = customGames.findIndex(c => c.name === game.name);
        if(idx2 === -1){
          showToast('Could not find the custom game to delete.', { type: 'error' });
          return;
        } else {
          idx = idx2;
        }
      }

      // Save a backup for undo
      const deletedGame = customGames[idx];
      const lastPlayedBackup = lastPlayed[deletedGame.name];

      // Remove the game
      customGames.splice(idx, 1);
      saveCustomGames();
      try{
        delete lastPlayed[deletedGame.name];
        saveLastPlayed();
      }catch(e){}

      renderGames(searchInput.value);

      // Show a toast with an Undo action. Duration remains default (2000ms) as before.
      showToast(`Deleted "${deletedGame.name}".`, {
        type: 'info',
        action: {
          label: 'Undo',
          onClick: () => {
            try {
              // Only restore if not already present (avoid duplicates)
              const exists = customGames.findIndex(c => c.name === deletedGame.name && c.code === deletedGame.code) !== -1;
              if(!exists){
                // Re-insert at the same index (or end if out of bounds)
                const insertAt = Math.min(Math.max(0, idx), customGames.length);
                customGames.splice(insertAt, 0, deletedGame);
                saveCustomGames();
                if(typeof lastPlayedBackup !== 'undefined'){
                  lastPlayed[deletedGame.name] = lastPlayedBackup;
                  saveLastPlayed();
                }
                renderGames(searchInput.value);
                showToast(`Restored "${deletedGame.name}".`, { type: 'success' });
              } else {
                showToast('Could not restore — entry already exists.', { type: 'warn' });
              }
            } catch (err) {
              console.warn('Undo failed', err);
              showToast('Undo failed.', { type: 'error' });
            }
          }
        }
      });
    }

    // Embed link / html inputs (same behavior)
    const linkInput = document.getElementById('link');
    const embedBtn = document.getElementById('embedBtn');
    const htmlCode = document.getElementById('htmlCode');
    const embedHtmlBtn = document.getElementById('embedHtmlBtn');

    function normalizeUrl(raw){ if(!raw) return null; raw = raw.trim(); if(!/^https?:\/\//i.test(raw)) raw = 'https://' + raw; try{ return new URL(raw).href } catch(e){ return null } }

    linkInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); embedLink(); } });
    embedBtn.addEventListener('click', embedLink);
    embedHtmlBtn.addEventListener('click', embedHtml);

    function embedLink(){
      const url = normalizeUrl(linkInput.value);
      if(!url) {
        showToast('Please enter a valid URL first.', { type: 'warn' });
        return;
      }
      const newWin = window.open('about:blank','_blank');
      if(!newWin) { showToast('Unable to open new window. Popup blocked?', { type: 'error' }); return; }
      const html = `<!doctype html>
<html lang="en">
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><style>html,body{height:100%;margin:0;background:#121420}iframe{position:fixed;inset:0;border:0;width:100%;height:100%}</style></head>
<body>
  <iframe src="${escapeAttr(url)}" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-pointer-lock allow-popups-to-escape-sandbox" allow="fullscreen; pointer-lock"></iframe>
</body>
</html>`;
      newWin.document.open(); newWin.document.write(html); newWin.document.close();
      // NOTE: per request, do not show a toast when embedding a URL successfully.
    }

    function embedHtml(){
      const code = htmlCode.value || '';
      if(!code.trim()) {
        showToast('Please enter some HTML code.', { type: 'warn' });
        return;
      }
      const newWin = window.open('about:blank','_blank');
      if(!newWin){ showToast('Unable to open new window. Popup blocked?', { type: 'error' }); return; }
      newWin.document.open(); newWin.document.write(code); newWin.document.close();
      // NOTE: per request, do not show a toast when embedding HTML successfully.
    }

    function escapeAttr(s){ return String(s).replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[ch])); }

    // ---------- Changed detection logic ----------
    // More aggressive detection: if we are running inside an iframe (window.top !== window.self),
    // many hosts (OneCompiler etc.) sandbox the frame and disallow downloads even when the sandbox attribute isn't readable.
    // Treat being inside an iframe as "download not allowed" so we fall back to the new-tab path reliably.
    function isDownloadAllowedInThisContext(){
      try {
        // If running inside an iframe, assume downloads are disallowed in many hosted runtimes (OneCompiler, etc.)
        if (window.top !== window.self) {
          console.warn('Detected iframe environment (window.top !== window.self) — treating as download-disallowed so fallback will be used.');
          return false;
        }
        const frame = window.frameElement;
        if(!frame) return true; // top-level window, allow
        if(frame.hasAttribute && frame.hasAttribute('sandbox')) {
          // If sandboxed, check tokens
          const raw = String(frame.getAttribute('sandbox') || '');
          const tokens = raw.split(/\s+/).filter(Boolean);
          const allow = tokens.includes('allow-downloads');
          if(!allow) console.warn('Frame sandbox present without allow-downloads — treating downloads as disallowed.');
          return allow;
        }
        return true;
      } catch (err) {
        // conservative fallback: disallow if anything goes wrong or cross-origin access prevented
        console.warn('Error checking frame sandbox/download capability — treating as download-disallowed.', err);
        return false;
      }
    }
    // ---------- end changed detection logic ----------

    // initialize settings UI states from loaded settings
    function reflectSettingsToUI(){
      // Only update UI controls — do NOT force view visibility.
      setSwitchState(toggleHighlight, settings.highlightCustom);
      setSwitchState(toggleLastPlayed, settings.showLastPlayed);
      setSwitchState(toggleMainMenu, settings.showMainMenu);

      // update custom-select label and selected states
      updateSortUI();
      updateShowFilterUI();

      // Show or hide the Back button depending on whether main menu is enabled.
      // Important: don't change which page (main/games/add) is currently visible here.
      backBtn.style.display = settings.showMainMenu ? '' : 'none';
    }
    function setSwitchState(btn, on){
      if(on){
        btn.classList.remove('off'); btn.classList.add('on');
        btn.setAttribute('aria-pressed', 'true');
        btn.setAttribute('aria-checked', 'true');
      } else {
        btn.classList.remove('on'); btn.classList.add('off');
        btn.setAttribute('aria-pressed', 'false');
        btn.setAttribute('aria-checked', 'false');
      }
    }

    // toggle handlers (also support keyboard activation)
    function addSwitchBehavior(btn, handler){
      btn.addEventListener('click', (e) => {
        handler();
      });
      btn.addEventListener('keydown', (e) => {
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          handler();
        }
      });
    }

    addSwitchBehavior(toggleHighlight, () => {
      settings.highlightCustom = !settings.highlightCustom;
      setSwitchState(toggleHighlight, settings.highlightCustom);
      saveSettings();
      renderGames(searchInput.value);
    });
    addSwitchBehavior(toggleLastPlayed, () => {
      settings.showLastPlayed = !settings.showLastPlayed;
      setSwitchState(toggleLastPlayed, settings.showLastPlayed);
      saveSettings();
      renderGames(searchInput.value);
    });

    // new: toggle main menu behaviour
    addSwitchBehavior(toggleMainMenu, () => {
      settings.showMainMenu = !settings.showMainMenu;
      setSwitchState(toggleMainMenu, settings.showMainMenu);
      saveSettings();

      // apply visibility immediately.
      // If main menu is turned off while user is viewing main, switch them to games.
      if(settings.showMainMenu){
        backBtn.style.display = '';
      } else {
        // if they currently are on the main view, send them to games
        if(!mainView.classList.contains('hidden')) {
          showGames();
        }
        backBtn.style.display = 'none';
      }
    });

    // --- custom select behavior (sort) ---
    function updateSortUI(){
      const label = settings.sort === 'recent' ? 'Recently played' : 'Alphabetically';
      sortSelectBtn.textContent = label;
      // update aria-selected on options
      Array.from(sortOptions.querySelectorAll('.custom-option')).forEach(opt => {
        opt.setAttribute('aria-selected', opt.dataset.value === settings.sort ? 'true' : 'false');
      });
    }
    function openSortPanel(){
      sortOptions.classList.add('open');
      sortSelectBtn.setAttribute('aria-expanded','true');
      sortOptions.setAttribute('aria-hidden','false');
    }
    function closeSortPanel(){
      sortOptions.classList.remove('open');
      sortSelectBtn.setAttribute('aria-expanded','false');
      sortOptions.setAttribute('aria-hidden','true');
    }
    function toggleSortPanel(){
      if(sortOptions.classList.contains('open')) closeSortPanel();
      else openSortPanel();
    }

    // click handlers for the custom options
    sortSelectBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleSortPanel();
    });
    sortSelectBtn.addEventListener('keydown', (e) => {
      if(e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar'){
        e.preventDefault();
        toggleSortPanel();
      } else if(e.key === 'ArrowDown'){
        e.preventDefault();
        openSortPanel();
        focusFirstOption(sortOptions);
      }
    });

    function focusFirstOption(panel){
      const first = panel.querySelector('.custom-option');
      if(first) first.focus();
    }

    // delegate clicks on options
    sortOptions.addEventListener('click', (e) => {
      const opt = e.target.closest('.custom-option');
      if(!opt) return;
      const val = opt.dataset.value;
      settings.sort = val;
      saveSettings();
      updateSortUI();
      renderGames(searchInput.value);
      closeSortPanel();
    });

    // keyboard support for options
    sortOptions.addEventListener('keydown', (e) => {
      const focused = document.activeElement;
      if(!focused || !focused.classList.contains('custom-option')) return;
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        focused.click();
      } else if(e.key === 'ArrowDown'){
        e.preventDefault();
        const next = focused.nextElementSibling;
        if(next && next.classList.contains('custom-option')) next.focus();
      } else if(e.key === 'ArrowUp'){
        e.preventDefault();
        const prev = focused.previousElementSibling;
        if(prev && prev.classList.contains('custom-option')) prev.focus();
        else sortSelectBtn.focus();
      } else if(e.key === 'Escape'){
        e.preventDefault();
        closeSortPanel();
        sortSelectBtn.focus();
      }
    });

    // --- showFilter custom select behavior (new) ---
    function updateShowFilterUI(){
      const label = settings.showFilter === 'built' ? 'Built-in only' : settings.showFilter === 'custom' ? 'Custom only' : 'All games';
      showFilterSelectBtn.textContent = label;
      Array.from(showFilterOptions.querySelectorAll('.custom-option')).forEach(opt => {
        opt.setAttribute('aria-selected', opt.dataset.value === settings.showFilter ? 'true' : 'false');
      });
    }
    function openShowFilterPanel(){
      showFilterOptions.classList.add('open');
      showFilterSelectBtn.setAttribute('aria-expanded','true');
      showFilterOptions.setAttribute('aria-hidden','false');
    }
    function closeShowFilterPanel(){
      showFilterOptions.classList.remove('open');
      showFilterSelectBtn.setAttribute('aria-expanded','false');
      showFilterOptions.setAttribute('aria-hidden','true');
    }
    function toggleShowFilterPanel(){
      if(showFilterOptions.classList.contains('open')) closeShowFilterPanel();
      else openShowFilterPanel();
    }

    showFilterSelectBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleShowFilterPanel();
    });
    showFilterSelectBtn.addEventListener('keydown', (e) => {
      if(e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar'){
        e.preventDefault();
        toggleShowFilterPanel();
      } else if(e.key === 'ArrowDown'){
        e.preventDefault();
        openShowFilterPanel();
        focusFirstOption(showFilterOptions);
      }
    });

    showFilterOptions.addEventListener('click', (e) => {
      const opt = e.target.closest('.custom-option');
      if(!opt) return;
      const val = opt.dataset.value;
      settings.showFilter = val;
      saveSettings();
      updateShowFilterUI();
      renderGames(searchInput.value);
      closeShowFilterPanel();
    });

    showFilterOptions.addEventListener('keydown', (e) => {
      const focused = document.activeElement;
      if(!focused || !focused.classList.contains('custom-option')) return;
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        focused.click();
      } else if(e.key === 'ArrowDown'){
        e.preventDefault();
        const next = focused.nextElementSibling;
        if(next && next.classList.contains('custom-option')) next.focus();
      } else if(e.key === 'ArrowUp'){
        e.preventDefault();
        const prev = focused.previousElementSibling;
        if(prev && prev.classList.contains('custom-option')) prev.focus();
        else showFilterSelectBtn.focus();
      } else if(e.key === 'Escape'){
        e.preventDefault();
        closeShowFilterPanel();
        showFilterSelectBtn.focus();
      }
    });

    // close panels when clicking outside either custom-select
    document.addEventListener('click', (e) => {
      if(sortOptions.classList.contains('open') && !document.getElementById('sortSelect').contains(e.target)) {
        closeSortPanel();
      }
      if(showFilterOptions.classList.contains('open') && !document.getElementById('showFilterSelect').contains(e.target)) {
        closeShowFilterPanel();
      }
    });

    // set initial UI for sort
    updateSortUI();
    updateShowFilterUI();

    // deleteAll handlers remain, but show toasts
    addSwitchBehavior(toggleMainMenu, () => {});
    // Note: the above line was previously used to register toggle. It's safe - real handler already registered earlier via addSwitchBehavior(toggleMainMenu,...)

    // delete all custom games (now using modal) - UPDATED: supports Undo via toast action
    deleteAllCustom.addEventListener('click', async () => {
      const ok = await confirmDialog('Delete ALL custom games? This cannot be undone.', { title: 'Delete All Custom Games', confirmText: 'Delete All', cancelText: 'Cancel', destructive: true });
      if(!ok) return;

      // Backup state for undo
      const backupCustomGames = JSON.parse(JSON.stringify(customGames));
      const backupLastPlayed = {};
      backupCustomGames.forEach(g => {
        if(typeof lastPlayed[g.name] !== 'undefined') backupLastPlayed[g.name] = lastPlayed[g.name];
      });

      // Perform deletion
      customGames = [];
      saveCustomGames();

      // Optionally remove lastPlayed entries for removed custom games (consistent with single-delete behavior)
      try {
        backupCustomGames.forEach(g => {
          if(typeof lastPlayed[g.name] !== 'undefined') {
            delete lastPlayed[g.name];
          }
        });
        saveLastPlayed();
      } catch (e) {
        console.warn('Failed to update lastPlayed after deleting all custom games', e);
      }

      renderGames(searchInput.value);

      // Show toast with Undo action
      showToast('All custom games deleted.', {
        type: 'info',
        action: {
          label: 'Undo',
          onClick: () => {
            try {
              // restore custom games and lastPlayed
              customGames = backupCustomGames.map(g => ({ name: g.name, code: g.code, built: false }));
              saveCustomGames();
              Object.keys(backupLastPlayed).forEach(k => { lastPlayed[k] = backupLastPlayed[k]; });
              saveLastPlayed();
              renderGames(searchInput.value);
              showToast('Restored custom games.', { type: 'success' });
            } catch (err) {
              console.warn('Undo restore failed for deleteAllCustom', err);
              showToast('Undo failed.', { type: 'error' });
            }
          }
        }
      });
    });

    // Delete all local storage for this app (custom games, settings, lastPlayed) (now using modal) - UPDATED: supports Undo via toast action
    deleteAllLocalStorage.addEventListener('click', async () => {
      const ok = await confirmDialog('Delete ALL local storage for this app? This will remove custom games, settings and last-played.', { title: 'Clear Local Storage', confirmText: 'Clear All', cancelText: 'Cancel', destructive: true });
      if(!ok) return;

      // Backup current state for undo
      const backup = {
        customGames: JSON.parse(JSON.stringify(customGames)),
        settings: JSON.parse(JSON.stringify(settings)),
        lastPlayed: JSON.parse(JSON.stringify(lastPlayed))
      };

      try {
        // remove keys used by the app
        localStorage.removeItem(LOCAL_KEY);
        localStorage.removeItem(SETTINGS_KEY);
        localStorage.removeItem(LAST_PLAYED_KEY);

        // reset in-memory state
        customGames = [];
        settings = { ...defaultSettings };
        lastPlayed = {};

        // persist the empty/reset state (keeps code paths consistent)
        saveCustomGames();
        saveSettings();
        saveLastPlayed();

        // update UI
        reflectSettingsToUI();
        renderGames(searchInput.value);

        // Show toast with Undo action
        showToast('Local storage cleared.', {
          type: 'success',
          action: {
            label: 'Undo',
            onClick: () => {
              try {
                // restore from backup
                customGames = (backup.customGames || []).map(g => ({ name: g.name, code: g.code, built: false }));
                settings = Object.assign({}, defaultSettings, backup.settings || {});
                lastPlayed = backup.lastPlayed || {};

                // persist restored state
                saveCustomGames();
                saveSettings();
                saveLastPlayed();

                reflectSettingsToUI();
                renderGames(searchInput.value);
                showToast('Local storage restored.', { type: 'success' });
              } catch (err) {
                console.warn('Undo failed for clear local storage', err);
                showToast('Undo failed.', { type: 'error' });
              }
            }
          }
        });
      } catch (e) {
        console.warn('Failed to clear local storage', e);
        showToast('Failed to clear local storage — see console for details.', { type: 'error' });
      }
    });

    // settings open/close behaviors
    function openSettings(){
      settingsOverlay.classList.add('show');
      settingsPanel.classList.remove('pop');
      void settingsPanel.offsetWidth;
      settingsPanel.classList.add('pop');
      settingsOverlay.setAttribute('aria-hidden', 'false');
      reflectSettingsToUI(); // now only updates controls, won't force views
    }
   
    function closeSettingsFunc(){
      settingsPanel.classList.add('leave');
      settingsOverlay.classList.add('hide');
      settingsOverlay.setAttribute('aria-hidden', 'true');

      const cleanup = (ev) => {
        settingsOverlay.classList.remove('show','hide');
        settingsPanel.classList.remove('pop','leave');
        settingsOverlay.removeEventListener('transitionend', cleanup);
      };
      settingsOverlay.addEventListener('transitionend', cleanup);

      setTimeout(() => {
        if(settingsOverlay.classList.contains('hide')) {
          settingsOverlay.classList.remove('show','hide');
          settingsPanel.classList.remove('pop','leave');
        }
      }, 320);
    }

    settingsBtn.addEventListener('click', openSettings);
    closeSettings.addEventListener('click', closeSettingsFunc);
    settingsOverlay.addEventListener('click', (e) => {
      if(e.target === settingsOverlay) closeSettingsFunc();
    });

    // keyboard: Esc closes settings; Esc in Add Game returns to Games; Esc in Games returns to Main
    document.addEventListener('keydown', (e) => {
      if(e.key === 'Escape'){
        if(settingsOverlay.classList.contains('show')) {
          closeSettingsFunc();
        } else if(!addGameView.classList.contains('hidden')) {
          showGames();
        } else if(!gamesView.classList.contains('hidden')) {
          showMain();
        }
      }
    });

    // initialize page
    linkInput.value = '';
    htmlCode.value = '';
    reflectSettingsToUI();

    // If main menu is disabled at load, ensure user is brought to games view
    if(!settings.showMainMenu) {
      showGames();
    }

    renderGames();

    // Import / Export handlers
    importStorageBtn.addEventListener('click', () => {
      // trigger hidden file input
      importFileInput.value = '';
      importFileInput.click();
    });

    importFileInput.addEventListener('change', (e) => {
      const file = (e.target.files && e.target.files[0]) || null;
      if(!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try{
          const text = String(ev.target.result || '');
          const parsed = JSON.parse(text);
          // accept either:
          // - object with keys { customGames, settings, lastPlayed }
          // - or an array representing customGames
          if(Array.isArray(parsed)){
            // treat as custom games array
            const imported = parsed.map(p => ({ name: String(p.name || ''), code: String(p.code || ''), built: false }));
            customGames = imported;
            saveCustomGames();
            renderGames(searchInput.value);
            showToast('Imported custom games.', { type: 'success' });
          } else if(parsed && typeof parsed === 'object'){
            if(Array.isArray(parsed.customGames)){
              customGames = parsed.customGames.map(p => ({ name: String(p.name || ''), code: String(p.code || ''), built: false }));
            }
            if(parsed.settings && typeof parsed.settings === 'object'){
              settings = Object.assign({}, defaultSettings, parsed.settings);
            }
            if(parsed.lastPlayed && typeof parsed.lastPlayed === 'object'){
              lastPlayed = parsed.lastPlayed;
            }
            // persist
            saveCustomGames();
            saveSettings();
            saveLastPlayed();
            reflectSettingsToUI();
            renderGames(searchInput.value);
            showToast('Import successful.', { type: 'success' });
          } else {
            throw new Error('Unexpected JSON structure');
          }
        }catch(err){
          console.warn('Failed to import', err);
          showToast('Import failed: invalid JSON.', { type: 'error' });
        }
      };
      reader.onerror = () => {
        showToast('Failed to read file.', { type: 'error' });
      };
      reader.readAsText(file);
    });

    // Export logic:
    // 1) Try to create downloadable blob and trigger anchor click.
    // 2) If that fails (sandboxed download, security error, popup blocked etc.), attempt to open a new tab and write the JSON into it.
    // 3) If opening a new tab is blocked, show a toast error (in-page JSON fallback was removed per request).
    exportStorageBtn.addEventListener('click', async () => {
      const payload = {
        customGames: customGames.map(g => ({ name: g.name, code: g.code })),
        settings: settings,
        lastPlayed: lastPlayed
      };
      const json = JSON.stringify(payload, null, 2);

      // If we're inside a sandboxed iframe that doesn't allow downloads, skip trying to trigger a download via anchor.click
      // because many embed environments (OneCompiler, etc.) will silently block the download without throwing an error.
      // Detect and short-circuit to the new-tab path to ensure user sees content.
      if(!isDownloadAllowedInThisContext()){
        try {
          console.warn('isDownloadAllowedInThisContext returned false — trying new-tab fallback next.');
          const newWin = window.open('about:blank', '_blank');
          if(newWin) {
            // NOTE: removed background color from the pre block per request.
            newWin.document.open();
            newWin.document.write(`<pre style="white-space:pre-wrap; word-break:break-word; padding:16px; font-family:monospace;">${escapeHtml(json)}</pre>`);
            newWin.document.close();
            showToast('Export fallback opened in new tab.', { type: 'info' });
            return;
          } else {
            // new tab blocked — we no longer show an in-page JSON block; inform user instead
            console.warn('New tab blocked; cannot show JSON in-page because fallback was removed by request.');
            showToast('Export failed: unable to download or open a new tab (popup blocked).', { type: 'error' });
            return;
          }
        } catch (err2) {
          console.warn('New-tab fallback failed', err2);
          showToast('Export failed: unable to download or open a new tab.', { type: 'error' });
          return;
        }
      }

      // Otherwise try the normal download flow (most hosts)
      try {
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        a.download = `embed_playground_export_${ts}.json`;
        // Append, click, remove. Some environments (sandboxed frames) disallow the download.
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        showToast('Export started.', { type: 'success' });

        // Note: in some sandboxed contexts the anchor click does not throw but also does not start a download.
        // Since we proactively checked for sandbox tokens above (and return false if inside an iframe),
        // this branch should be executed only when downloads are likely allowed.
      } catch (e) {
        // Primary download failed (e.g. sandboxed download disallowed)
        console.warn('Download failed - attempting new tab fallback', e);
        // Try to open in a new tab first
        try {
          const newWin = window.open('about:blank', '_blank');
          if(newWin) {
            newWin.document.open();
            // NOTE: removed background color from the pre block per request.
            newWin.document.write(`<pre style="white-space:pre-wrap; word-break:break-word; padding:16px; font-family:monospace;">${escapeHtml(json)}</pre>`);
            newWin.document.close();
            showToast('Export fallback opened in new tab.', { type: 'info' });
            return;
          } else {
            // new tab blocked — we no longer show an in-page JSON block; inform user instead
            showToast('Export failed: unable to download or open a new tab (popup blocked).', { type: 'error' });
            return;
          }
        } catch (err2) {
          console.warn('New-tab fallback failed', err2);
          showToast('Export failed: unable to download or open a new tab.', { type: 'error' });
          return;
        }
      }
    });

    // Developer helper (commented out by default)
    // window.__resetAll = function(){ localStorage.removeItem(LOCAL_KEY); localStorage.removeItem(SETTINGS_KEY); localStorage.removeItem(LAST_PLAYED_KEY); customGames = []; settings = {...defaultSettings}; lastPlayed = {}; saveCustomGames(); saveSettings(); saveLastPlayed(); renderGames(); };
  </script>
</body>
</html>

<!--

  Created by Huaze
  Version: Beta 1.6.3
  For more info, see: https://github.com/Huaze2/Games

-->
